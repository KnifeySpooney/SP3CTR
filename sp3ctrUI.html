<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SP3CTR 0.0.2 - WebSocket Client</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom scrollbar for a more 'technical' feel, inspired by classic tools */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1a202c; /* dark-900 */
        }
        ::-webkit-scrollbar-thumb {
            background: #4a5568; /* gray-600 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #718096; /* gray-500 */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Tailwind's gray-900 for a dark theme */
            color: #e2e8f0; /* Tailwind's gray-300 for text */
        }
        .table-fixed-layout {
            table-layout: fixed;
        }
        .active-glow {
            box-shadow: 0 0 8px 2px rgba(56, 189, 248, 0.5); /* sky-400 glow */
        }
        .btn {
            @apply px-4 py-2 rounded-md font-semibold transition-all duration-150 ease-in-out shadow-md;
        }
        .btn-start {
            @apply bg-green-500 hover:bg-green-600 text-white;
        }
        .btn-stop {
            @apply bg-red-500 hover:bg-red-600 text-white;
        }
        .btn-disabled {
            @apply bg-gray-600 text-gray-400 cursor-not-allowed;
        }
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        .status-capturing {
            background-color: #34d399; /* emerald-400 */
            animation: pulse-green 1.5s infinite;
        }
        .status-stopped {
            background-color: #ef4444; /* red-500 */
        }
        .status-connecting {
            background-color: #f59e0b; /* amber-500 */
            animation: pulse-amber 1.5s infinite;
        }
        @keyframes pulse-green {
            0% { box-shadow: 0 0 0 0 rgba(52, 211, 153, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(52, 211, 153, 0); }
            100% { box-shadow: 0 0 0 0 rgba(52, 211, 153, 0); }
        }
        @keyframes pulse-amber {
            0% { box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(245, 158, 11, 0); }
            100% { box-shadow: 0 0 0 0 rgba(245, 158, 11, 0); }
        }
        select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%239ca3af' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        .toast {
            @apply fixed bottom-5 right-5 p-3 rounded-md shadow-lg text-sm z-50;
            animation: fadeInOut 4s ease-in-out;
        }
        .toast-error { @apply bg-red-600 text-white; }
        .toast-info { @apply bg-sky-600 text-white; }
        @keyframes fadeInOut {
            0%, 100% { opacity: 0; transform: translateY(20px); }
            10%, 90% { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body class="flex flex-col min-h-screen">

    <header class="bg-gray-800 p-4 shadow-lg">
        <h1 class="text-2xl font-bold text-sky-400 text-center">SP3CTR <span class="text-sm text-gray-400">0.0.2</span></h1>
        <p class="text-sm text-gray-400 text-center">Spectral Packet Capture & Threat Recognition</p>
    </header>

    <section id="controls" class="bg-gray-800 p-4 m-4 rounded-lg shadow-md">
        <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
            <div class="flex-grow">
                <label for="network-interface" class="block text-sm font-medium text-gray-300 mb-1">Network Interface:</label>
                <select id="network-interface" class="w-full bg-gray-700 border border-gray-600 text-gray-200 rounded-md p-2 focus:ring-sky-500 focus:border-sky-500">
                    <option value="">Connecting to server...</option>
                </select>
            </div>
            <div class="flex items-end gap-2 mt-2 sm:mt-0">
                <button id="start-capture-btn" class="btn btn-start w-full sm:w-auto btn-disabled" disabled>Start Capture</button>
                <button id="stop-capture-btn" class="btn btn-stop w-full sm:w-auto btn-disabled" disabled>Stop Capture</button>
            </div>
        </div>
        <div class="mt-3 flex items-center">
            <span id="status-indicator-light" class="status-indicator status-connecting"></span>
            <span id="capture-status" class="text-sm text-gray-400">Status: Connecting to WebSocket...</span>
        </div>
    </section>

    <main id="packet-display-area" class="flex-grow p-4 m-4 bg-gray-800 rounded-lg shadow-inner overflow-x-auto">
        <div class="overflow-y-auto h-[calc(100vh-300px)] sm:h-[calc(100vh-260px)]">
            <table class="min-w-full table-fixed-layout border-collapse">
                <thead class="sticky top-0 bg-gray-700 z-10">
                    <tr>
                        <th class="w-1/6 p-2 border border-gray-600 text-left text-sm font-semibold text-sky-300">Time</th>
                        <th class="w-1/6 p-2 border border-gray-600 text-left text-sm font-semibold text-sky-300">Source IP</th>
                        <th class="w-1/6 p-2 border border-gray-600 text-left text-sm font-semibold text-sky-300">Dest. IP</th>
                        <th class="w-1/12 p-2 border border-gray-600 text-left text-sm font-semibold text-sky-300">Proto</th>
                        <th class="w-1/12 p-2 border border-gray-600 text-left text-sm font-semibold text-sky-300">Length</th>
                        <th class="w-1/3 p-2 border border-gray-600 text-left text-sm font-semibold text-sky-300">Info</th>
                    </tr>
                </thead>
                <tbody id="packet-table-body" class="divide-y divide-gray-700">
                    <tr id="no-packets-row">
                        <td colspan="6" class="p-4 text-center text-gray-500">Waiting for WebSocket connection and data...</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </main>
    
    <div id="toast-container"></div>

    <footer class="p-3 bg-gray-800 text-center text-xs text-gray-500 shadow-lg mt-auto">
        SP3CTR 0.0.2 - WebSocket Connected.
    </footer>

    <script>
        // SP3CTR 0.0.2 - WebSocket Client Script

        const WEBSOCKET_URL = "ws://localhost:8765"; // Matches Python server
        let socket;

        const networkInterfaceSelect = document.getElementById('network-interface');
        const startCaptureBtn = document.getElementById('start-capture-btn');
        const stopCaptureBtn = document.getElementById('stop-capture-btn');
        const packetTableBody = document.getElementById('packet-table-body');
        const captureStatusEl = document.getElementById('capture-status');
        const statusIndicatorLightEl = document.getElementById('status-indicator-light');
        const noPacketsRow = document.getElementById('no-packets-row');
        const toastContainer = document.getElementById('toast-container');

        let isCapturing = false; // Local state for UI, server is source of truth

        function initialize() {
            console.log("SP3CTR 0.0.2: Initializing WebSocket client...");
            connectWebSocket();
            setupEventListeners();
            updateButtonStates(); // Initial state
        }

        function connectWebSocket() {
            socket = new WebSocket(WEBSOCKET_URL);

            socket.onopen = () => {
                console.log("WebSocket connection established.");
                captureStatusEl.textContent = "Status: Connected. Fetching interfaces...";
                statusIndicatorLightEl.className = 'status-indicator status-stopped'; // Connected, but not capturing
                // The server should send interfaces upon connection.
                // If not, we can request them: sendCommand({ command: "get_interfaces" });
            };

            socket.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    // console.log("Message from server:", message);
                    handleServerMessage(message);
                } catch (error) {
                    console.error("Error parsing message from server:", error, event.data);
                    showToast("Error processing server message.", "error");
                }
            };

            socket.onerror = (error) => {
                console.error("WebSocket error:", error);
                captureStatusEl.textContent = "Status: Connection Error. Is the Python server running?";
                statusIndicatorLightEl.className = 'status-indicator status-stopped';
                showToast("WebSocket connection error.", "error");
                disableAllControls();
            };

            socket.onclose = () => {
                console.log("WebSocket connection closed.");
                captureStatusEl.textContent = "Status: Disconnected. Please refresh or restart server.";
                statusIndicatorLightEl.className = 'status-indicator status-stopped';
                showToast("WebSocket disconnected.", "info");
                isCapturing = false; // Reset capture state
                disableAllControls();
            };
        }

        function disableAllControls() {
            startCaptureBtn.disabled = true;
            startCaptureBtn.classList.add('btn-disabled');
            stopCaptureBtn.disabled = true;
            stopCaptureBtn.classList.add('btn-disabled');
            networkInterfaceSelect.disabled = true;
        }


        function setupEventListeners() {
            startCaptureBtn.addEventListener('click', handleStartCapture);
            stopCaptureBtn.addEventListener('click', handleStopCapture);
        }
        
        function sendCommand(commandObject) {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(commandObject));
            } else {
                console.error("WebSocket is not open. Cannot send command.");
                showToast("Cannot send command: WebSocket not connected.", "error");
            }
        }

        function handleStartCapture() {
            const selectedInterface = networkInterfaceSelect.value;
            if (!selectedInterface) {
                showToast("Please select a network interface.", "error");
                return;
            }
            console.log(`Requesting start capture on ${selectedInterface}`);
            sendCommand({ command: "start_capture", interface: selectedInterface });
            // UI updates (e.g., isCapturing state) will be driven by server status messages
        }

        function handleStopCapture() {
            console.log("Requesting stop capture.");
            sendCommand({ command: "stop_capture" });
        }

        function handleServerMessage(message) {
            switch (message.type) {
                case "interfaces":
                    populateNetworkInterfaces(message.data);
                    captureStatusEl.textContent = "Status: Idle. Select interface and start capture.";
                    break;
                case "packet":
                    if (noPacketsRow && noPacketsRow.style.display !== 'none') {
                        noPacketsRow.style.display = 'none';
                    }
                    addPacketToDisplay(message.data);
                    break;
                case "status":
                    captureStatusEl.textContent = `Status: ${message.message}`;
                    if (message.message.toLowerCase().includes("capture started") || message.message.toLowerCase().includes("capture active")) {
                        isCapturing = true;
                        statusIndicatorLightEl.className = 'status-indicator status-capturing';
                    } else if (message.message.toLowerCase().includes("capture stopped") || message.message.toLowerCase().includes("idle")) {
                        isCapturing = false;
                        statusIndicatorLightEl.className = 'status-indicator status-stopped';
                    }
                    updateButtonStates();
                    break;
                case "error":
                    console.error("Server error:", message.message);
                    showToast(`Server Error: ${message.message}`, "error");
                    // Potentially update status too
                    // captureStatusEl.textContent = `Status: Error - ${message.message}`;
                    // isCapturing = false; // Assume error stops capture
                    // updateButtonStates();
                    break;
                default:
                    console.warn("Unknown message type from server:", message);
            }
        }

        function populateNetworkInterfaces(interfaces) {
            networkInterfaceSelect.innerHTML = ''; // Clear existing options
            if (interfaces && interfaces.length > 0) {
                interfaces.forEach(iface => {
                    const option = document.createElement('option');
                    option.value = iface.id; // Python server sends 'id'
                    option.textContent = iface.name; // Python server sends 'name'
                    networkInterfaceSelect.appendChild(option);
                });
                networkInterfaceSelect.disabled = false;
            } else {
                const option = document.createElement('option');
                option.value = "";
                option.textContent = "No interfaces found or server error.";
                networkInterfaceSelect.appendChild(option);
                networkInterfaceSelect.disabled = true;
            }
            updateButtonStates(); // Enable start button if interfaces are available
        }
        
        function updateButtonStates() {
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                disableAllControls();
                return;
            }

            const hasInterfaces = networkInterfaceSelect.options.length > 0 && networkInterfaceSelect.value !== "";

            if (isCapturing) {
                startCaptureBtn.disabled = true;
                startCaptureBtn.classList.add('btn-disabled');
                stopCaptureBtn.disabled = false;
                stopCaptureBtn.classList.remove('btn-disabled');
                networkInterfaceSelect.disabled = true;
            } else {
                startCaptureBtn.disabled = !hasInterfaces; // Only enable if interfaces are loaded
                startCaptureBtn.classList.toggle('btn-disabled', !hasInterfaces);
                stopCaptureBtn.disabled = true;
                stopCaptureBtn.classList.add('btn-disabled');
                networkInterfaceSelect.disabled = false;
            }
        }

        function addPacketToDisplay(packetData) {
            const row = packetTableBody.insertRow(0); // Insert at the top
            row.className = 'hover:bg-gray-700 transition-colors duration-150';

            const createCell = (text, ...classes) => {
                const cell = row.insertCell();
                cell.className = `p-2 border-b border-gray-700 text-xs ${classes.join(' ')}`;
                cell.textContent = text;
                return cell;
            };

            createCell(packetData.timestamp);
            createCell(packetData.srcIp, 'font-mono');
            createCell(packetData.destIp, 'font-mono');
            
            const protoCell = createCell(packetData.protocol);
            if (packetData.protocol === 'TCP') protoCell.classList.add('text-blue-400');
            else if (packetData.protocol === 'UDP') protoCell.classList.add('text-purple-400');
            else if (packetData.protocol === 'ICMP') protoCell.classList.add('text-red-400');
            else if (packetData.protocol === 'DNS') protoCell.classList.add('text-green-400');
            else if (packetData.protocol.toUpperCase().includes('HTTP')) protoCell.classList.add('text-orange-400'); // Broader match for HTTP/HTTPS
            else if (packetData.protocol.toUpperCase().includes('TLS') || packetData.protocol.toUpperCase().includes('SSL')) protoCell.classList.add('text-teal-400');
            
            createCell(packetData.length);
            const infoCell = createCell(packetData.info, 'truncate');
            infoCell.title = packetData.info; // Show full info on hover

            const maxRows = 200;
            if (packetTableBody.rows.length > maxRows) {
                packetTableBody.deleteRow(packetTableBody.rows.length - 1);
            }
        }

        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.textContent = message;
            toastContainer.appendChild(toast);
            setTimeout(() => {
                toast.remove();
            }, 3900); // Remove just before animation ends
        }

        document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
</html>
